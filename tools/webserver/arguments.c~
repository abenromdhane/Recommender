int parse_arguments (int argc, char** argv, k_fold_parameters_t *k_fold_params)
{


	size_t file_path_length = 0;
	int bin_width_ratio;
	if (argc < 15)
	{
		printf ("Incorrect arguments \n");
		printf ("usage: webserver 100000 943 1682 u.data 30 30 0.055 0.0095 0.02 0.001 bias \n kfold -h for help \n");
		if (strcmp (argv[1], "-h") )
		{
			printf ("kfold ratings_number K users_number items_number file_path \n");
			printf ("ratings_number : Number of ratings in the sample \n");
			printf ("K : Number of subsamples \n");
			printf ("users_number : number of users in the sample \n");
			printf ("items_number : number of items in the sample \n");
			printf ("file_path : the path of the samples file \n");
			printf ("dimentionality : dimentionality \n");
			printf ("iteration_number : the desired iteration's number \n");
			printf ("lambda : lambda \n");
			printf ("step : step \n");
			printf ("lambda_bias : lambda_bias \n");
			printf ("step_bias : step_bias \n");
			printf ("projection family number :  \n");
			printf ("bin width ratio \n");
			printf ("type : basic or bias \n");
		}
		system ("pause");
		return (-1);
	}

	k_fold_params->ratings_number = atoi (argv[1]);
	k_fold_params->K = atoi (argv[2]);
	if (k_fold_params->K < 2)
	{
		printf ("K must be greater or equal than 2 \n ");
		system ("pause");
		return (-1);
	}
	k_fold_params->params.users_number = atoi (argv[3]);
	if (k_fold_params->params.users_number < 1)
	{
		printf ("users_number must be a positif integer \n ");
		system ("pause");
		return (-1);
	}
	k_fold_params->params.items_number = atoi (argv[4]);
	if (k_fold_params->params.items_number < 1)
	{
		printf ("items_number must be a positif integer \n ");
		system ("pause");
		return (-1);
	}

	file_path_length = strlen (argv[5]) + 1;

	k_fold_params->file_path = (char*) malloc (file_path_length);
	strcpy (k_fold_params->file_path, argv[5]);
	k_fold_params->params.training_set_size = k_fold_params->ratings_number;


	if (strcmp (argv[6], "x") == 0)
	{
		*param_to_find = & (k_fold_params->params.dimensionality);
		*is_float = 0;
	}
	else
	{
		k_fold_params->params.dimensionality = atoi (argv[6]);
		if (k_fold_params->params.dimensionality < 1)
		{
			printf ("dimensionality must be a positif integer \n ");
			system ("pause");
			exit (-1);
		}
	}
	if (strcmp (argv[7], "x") == 0)
	{
		*param_to_find = & (k_fold_params->params.iteration_number);
		*is_float = 0;
	}else
	{
	k_fold_params->params.iteration_number = atoi (argv[7]);
	if (k_fold_params->params.iteration_number < 1)
	{
		printf ("iteration_number must be a positif integer \n ");
		system ("pause");
		return (-1);
	}
	}

	if (strcmp (argv[8], "x") == 0)
	{
		*param_to_find = & (k_fold_params->params.lambda);
		*is_float = 1;
	}
	else
	{
		k_fold_params->params.lambda = (float) atof (argv[8]);
	}



	k_fold_params->params.step = (float) atof (argv[9]);

	if (strcmp (argv[10], "x") == 0)
	{
		*param_to_find = & (k_fold_params->params.lambda_bias);
		*is_float = 1;
	}
	else
	{
		k_fold_params->params.lambda_bias = (float) atof (argv[10]);
	}

	k_fold_params->params.step_bias = (float) atof (argv[11]);

	k_fold_params->params.proj_family_size = (int) atoi (argv[12]);

	bin_width_ratio = (int) atoi (argv[13]);

	if (strcmp (argv[14], "basic") == 0)
	{
		printf ("basic \n");
		k_fold_params->model.learning_algorithm  = learn_basic_mf;
		k_fold_params->model.rating_estimator = estimate_rating_basic_mf;
		k_fold_params->model.parameters.algoithm_type = 0;
	}
	else if (strcmp (argv[14], "bias") == 0)
	{
		printf ("bias \n");
		k_fold_params->model.learning_algorithm = learn_mf_bias;
		k_fold_params->model.rating_estimator   = estimate_rating_mf_bias;
		k_fold_params->model.update_algorithm = update_learning_with_training_set;
		k_fold_params->model.parameters.algoithm_type = BIAS;
	}
	else if (strcmp (argv[14], "MFneighbors") == 0)
	{
		printf ("MFneighbors \n");
		k_fold_params->model.learning_algorithm = learn_mf_neighbor;
		k_fold_params->model.rating_estimator   = estimate_rating_mf_neighbor;
		k_fold_params->model.update_algorithm = update_learning_with_training_set_neighborMF;
		k_fold_params->model.parameters.algoithm_type = NEIGHBOURS_MF;

	}else if (strcmp (argv[14], "social") == 0)
	{
		printf ("social \n");
		k_fold_params->model.learning_algorithm = learn_social;
		k_fold_params->model.rating_estimator   = estimate_rating_social;
		k_fold_params->params.algoithm_type = SOCIAL;
		if(argc!=18)
			return -1;
		k_fold_params->social_relations_file_path = malloc(strlen(argv[15]+1));
		strcpy(k_fold_params->social_relations_file_path,argv[15]);
		k_fold_params->social_relations_number = atoi(argv[16]);
		k_fold_params->params.betha=atoi(argv[17]);
		/**param_to_find = & (k_fold_params->params.betha);
		*is_float = 0;*/
	}
	else
	{
		printf ("type must be bias or basic");
		return -1;
	}
	k_fold_params->params.bin_width = (int)(k_fold_params->params.items_number * bin_width_ratio / 100.0);
	
	k_fold_params->params.seed = 4578;
	return 0;

}
